/**
 * 
 */
package edu.caltech.networksimulator;

import edu.caltech.networksimulator.datacapture.DataCaptureToolHelper;

/**
 * @author Carly
 *
 * Flows represent active connections.
 * Flows will have source and destination addresses; packets generated by each
 * flow will have the same destination address, to ensure they are routed correctly.
 * 
 * Flows have a source and destination address, and generate packets at a rate
 * controlled by the congestion control algorithm defined for that flow. You
 * should implement at least two different congestion control algorithms, e.g.
 * TCP Reno and FAST-TCP, and be able to choose independently between them for
 * each flow. Flows may send a continuous stream of data, or may send a finite
 * user-specifiable amount of data; they may also start immediately or after some
 * user-specifiable delay.
 */
public class Flow extends NetworkComponent {
	
	private static final String WINDOW_ALG = "None"; // for example
	private static final long TIMEOUT = 500;
	// probably want src as a networkComponent
	private final long src, dest;
	private final long data_size;
	private final long start_at;
	private final long num_packets;
	private int i; // how far along we are in the flow
	private int window;
	private int numSent;
	private long maxRTT;
	
	/**
	 * @param src The source IP
	 * @param dest The destination IP
	 * @param id The ID number of the flow
	 * @param data_size The amount of data to send as part of this flow, in MB
	 * @param start_delay The delay in starting to send this flow, in millis
	 */
	public Flow(long src, long dest, String name, long data_size, long start_delay) {
		super(name);
		this.src = src;
		this.dest = dest;
		this.data_size = data_size;
		this.start_at = System.currentTimeMillis() + start_delay;
		// convert MB to bytes then divide then round up
		this.num_packets = ((data_size * 1000000) / 1024) + 1;
		System.out.println(this.num_packets);
		this.i = 0;
		this.numSent = 0;
		this.window = 5; // fixed window size
	}
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		
	}
	
	public Packet getPacket() {
		if ((this.start_at < System.currentTimeMillis()) && (!this.finished()) && (this.numSent < this.window)) {
			this.numSent++;
			return new Packet(this.src, this.dest, "DOOM", this.i, this.getComponentName());
		}
		return null;
	}
	
	public void recievedACK(Packet p) {

		System.out.println("window size: " + getWindow());

		System.out.println(p.getPayload() + " flow index" + this.i);
		// Algorithm: send same packet at a time until done.
		if (p.getPayload().equals("ACK" + this.i)) {
			this.i = this.i + 1;
			this.numSent = 0;
			this.window += 1;
		} else {
		// It wasn't the right packet, assumed we dropped one.
		// TODO: Make this detection better
			
		}
		
	}
	
	@Override
	public String toString() {
		return "{Src: " + src + " Dest: " + dest + "}";
	}
	
	public long getIndex() {
		return this.i;
	}
	
	public int getWindow() {
		return this.window;
	}
	
	public int getNumSent() {
		return this.numSent;
	}

	public long getTotalPackets() {
		return num_packets;
	}
	
	public void adjustWindowSize(boolean dropped) {
		if (WINDOW_ALG == "Simple") {
			if (dropped) {
				this.window = Math.max(getWindow() - 1, 1);
			} else { // else received
				this.window += 1;
			}
		}
		return;
	}

	@Override
	public void offerPacket(Packet p, NetworkComponent n) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean finished() {
		return this.i >= this.num_packets;
	}

}
